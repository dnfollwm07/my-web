# HTML 腳本與性能

## 目錄
- [腳本加載](#腳本加載)
- [樣式表放置](#樣式表放置)
- [腳本放置](#腳本放置)
- [漸進式渲染](#漸進式渲染)
- [HTML 模板語言](#html-模板語言)
- [事件委派](#事件委派)

## 腳本加載

### `<script>`、`<script async>` 和 `<script defer>`

* `<script>` 
  * HTML **解析被阻塞**
  * 腳本被獲取並在下載後**立即執行**
  * HTML 解析在腳本**執行後**恢復

  > 會立即執行腳本，但阻塞 HTML 解析
  >
  > fetch -> **execute** -> parse

* `<script async>` 
  * 腳本將**並行**於 HTML 解析進行獲取
  * **一旦可用**就執行（可能在 HTML 解析完成之前）
  * 當腳本獨立於頁面上的任何其他腳本時使用 `async`，例如分析工具。

  > 可以提高網頁性能，適用於不依賴頁面 DOM 結構的腳本
  >
  > fetch   -> **execute**
  >
  > parsing - ...

* `<script defer>` 
  * 腳本將並行於 HTML 解析進行獲取
  * 在頁面**解析完成後**執行

  > 對依賴完整 DOM 的腳本最合適，保證 HTML 全部解析完畢後才執行，並按照出現順序執行
  >
  > fetch   -> ready - **execute**
  >
  > parsing -> ready /

  * 如果有多個延遲腳本，每個延遲腳本將按照它們在文檔中出現的**順序**執行
  * 當腳本依賴於**完全解析的 DOM**時，`defer` 屬性對於確保 HTML 在執行前完全解析非常有用。
  * 延遲腳本不得包含 `document.write`

!! 對於沒有 `src` 屬性的腳本，`async` 和 `defer` 屬性會被忽略 !!

## 樣式表放置

* 將這些腳本放在 `<head>` 標籤中，它們會更早開始執行

  將樣式表放置於 `<head>` 中可幫助瀏覽器在頁面顯示時渲染出完整樣式，提升用戶體驗和頁面性能，避免用戶在頁面加載過程中看到空白頁

* 將 `<script>` 放在底部意味著瀏覽器在整個文檔解析完成之前無法開始下載腳本

  若將樣式表放在文檔底部，許多瀏覽器會無法進行**漸進式渲染**。有些瀏覽器會阻止渲染，以避免頁面樣式變更後必須重新繪製

  ```html
  <head>
    ...
    <!-- 引入外部樣式表 -->
    <link rel="stylesheet" href="styles.css">
  </head>
  ```

## 腳本放置

* 將腳本放在關閉的 `</body>` 標籤之前可以使頁面加載得更快

  將 `<script>` 標籤放在 `</body>` 閉合標籤前可以提高頁面的加載速度

* 因為 `<script>` 標籤在下載和執行時會阻塞 HTML 解析，這可能會拖慢您的頁面

  `<script>`標籤在下載和執行時會暫停 HTML 解析，這可能會拖慢頁面加載速度。

* 然而，如果您有一些代碼想在頁面加載期間運行，它只會在整個頁面加載後才開始執行。如果您將這些腳本放在 `<head>` 標籤中，它們會更早開始執行 - 所以在預加載緩存的情況下，頁面實際上會看起來加載得更快。

  然而，如果有需要在頁面加載過程中執行的代碼，放在底部會讓這些腳本直到頁面完全加載後才執行。如果將腳本放在 `<head>` 中，它們會更早地開始執行，從而在有緩存的情況下頁面看起來會加載得更快。

## 漸進式渲染

* 用於提高網頁性能以渲染顯示內容的技術

  * 圖像的懶加載

    * 頁面上的圖像**不是一次性全部加載**
    * 當用戶滾動到頁面的該部分時加載圖像

  * 優先顯示可見內容

    * 僅包含用戶瀏覽器中首先渲染的頁面部分所需的**最少 CSS/內容/腳本**，以盡快顯示
    * 使用**延遲腳本**或監聽 `DOMContentLoaded`/`load` 事件來加載其他資源和內容

  * 異步 HTML 片段

    * 在頁面仍在後端構建時，首先將部分 HTML 傳輸到瀏覽器

      當頁面在後端構建時，將部分 HTML 內容提前「刷新」到瀏覽器

    * 這種技術可以在**後端生成 HTML 的過程**中，將已經處理完的部分 HTML **即時發送到瀏覽器**，而不是等整個頁面完全構建完畢才發送。

## HTML 模板語言

1. **Mustache**：一種邏輯少的模板語言，使用花括號語法，適用於多種語言的模板引擎。
2. **Nunjucks**：由 Mozilla 開發的高性能模板引擎，具有強大的功能和靈活性，適合 Node.js 和瀏覽器端使用。
3. **Twig**：PHP 的一種模板引擎，語法簡潔，支持繼承和擴展，非常適合構建複雜的應用。
4. **Dot (doT)**：輕量級模板引擎，速度快，使用簡單，適合高效的渲染。
5. **Smarty**：一個成熟的 PHP 模板引擎，支持複雜的邏輯和模板繼承。

## 事件委派

- 一種將**單個事件監聽器**附加到**父元素**以管理其**子元素**事件的技術。

  將事件監聽器附加到父元素上，以管理子元素事件的技術。

- 事件委派是一種通過在父級元素上註冊事件監聽器，可以監控所有子元素的事件，而不需要為每個子元素單獨添加監聽器。

- 適用於處理**動態創建元素**上的事件和**減少內存消耗**

  這種技術特別適合用於動態生成的元素，因為新創建的元素自動繼承了父元素的事件監聽器。

- 優點：

  - 減少內存 (Memory) 消耗：只需為父元素設置一次監聽器，而不是為每個子元素都設置。
  - 動態 (dynamic) 內容支持：動態生成的元素不需要重新設置事件監聽器。

  ```javascript
  <ul id="parent">
    <li>Item 1</li>
    <li>Item 2</li>
  </ul>
  
  <script>
    const parent = document.getElementById('parent');
    parent.addEventListener('click', function(event) { 
      if (event.target.tagName === 'LI') {
        console.log('List item clicked:', event.target.textContent);
      }
    });
  </script>
  ```

  * 在這個例子中，click 事件監聽器被附加在 <ul> 父元素上，可以處理所有子 <li> 元素的點擊事件。

  * addEventListener: 

    `'click'`: 鼠標點擊

    `'keydown'`: 鍵盤按鍵

    `'mouseover'`: 當鼠標懸停在元素上

    `'scroll'`: 當用戶滾動頁面

    `'submit'`: 當表單提交時

    `'load'`: 當資源加載完成時（例如窗口或圖像）

    `'focus'`, `'blur'`: 當元素獲得或失去焦點時 